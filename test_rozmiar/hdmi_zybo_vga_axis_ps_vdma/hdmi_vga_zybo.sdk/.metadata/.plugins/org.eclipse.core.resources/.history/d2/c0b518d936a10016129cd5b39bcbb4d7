/*
 * Empty C++ Application
 */

#include "xparameters.h"
#include "platform.h"
#include "xil_printf.h"
#include "xil_io.h"
#include "sleep.h"
#include "xaxivdma.h"


// VDMA (write) registers
#define S2MM_VDMACR 0x30
#define S2MM_VDMASR 0x34
#define S2MM_VSIZE 0xA0
#define S2MM_HSIZE 0xA4
#define S2MM_FRMDLY_STRIDE 0xA8
#define S2MM_START_ADDRESS 0xAC

// Full (with blanking) input image sizes
#define HSIZE_FULL 1980
#define VSIZE_FULL 750

// Active (only video) image sizes
#define HSIZE_ACTVIE 1280
#define VSIZE_ACTIVE 720


// Buffer for input image
u32 hdmi_image[VSIZE_ACTIVE*HSIZE_ACTVIE] ={0};
volatile u32 hdmi_image2[VSIZE_ACTIVE*HSIZE_ACTVIE];


XAxiVdma AxiVdma;

int AxiVDMASelfTestExample(u16 DeviceId)
{
	XAxiVdma_Config *Config;
	int Status = XST_SUCCESS;

	Config = XAxiVdma_LookupConfig(DeviceId);
	if (!Config) {
			return XST_FAILURE;
	}

	/* Initialize DMA engine */
	Status = XAxiVdma_CfgInitialize(&AxiVdma, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	Status = XAxiVdma_Selftest(&AxiVdma);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	return Status;
}


int main()
{
	init_platform();

	xil_printf("VDMA image transfer \n\r");

	// Initialize VTC
	Xil_Out32(XPAR_V_TC_0_BASEADDR,0xC);

	// Czekanie na video
	int hsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0030);
	int vsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0034);

	xil_printf("Waiting for image stream to synchornize \n\r");
	while ( hsize_input <=1 && vsize_input <=1) {
		hsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0030);
		vsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0034);
	}
	xil_printf("Stream synchornized \n\r");




	// VDMA Self test
	int  Status = AxiVDMASelfTestExample(XPAR_AXI_VDMA_0_DEVICE_ID);
    if (Status != XST_SUCCESS)
    	xil_printf("AxiVDMASelfTestExample: Failed\r\n");
	else
		xil_printf("AxiVDMASelfTestExample: Passed\r\n");


	//u32* mem_address = &hdmi_image;
	xil_printf("Image address %X \r\n",(u32)(&hdmi_image2));

	// Initialize VDMA Write
	Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_VDMACR,0x8B); // run  8B
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_START_ADDRESS, (&hdmi_image2));
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_FRMDLY_STRIDE,HSIZE_ACTVIE*4);   // 0
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_HSIZE,HSIZE_ACTVIE*4);          // 4
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_VSIZE,VSIZE_ACTIVE);            //


    // Clear memory
    for (int j=0; j < VSIZE_ACTIVE*HSIZE_ACTVIE; j++) {  //
    	hdmi_image[j] = 10;
    	//xil_printf("%d ",hdmi_image[j]);
    }



	//int hsize_input, vsize_input;  					// rozdzielczosc - cala ramka - wejscie
	int hsize_active_input, vsize_active_input;  	// rozdzielczosc - tylko aktywyny obszar - wejscie

	int hsize_output, vsize_output;  				// rozdzielczosc - cala ramka - wyjscie
	int hsize_active_output, vsize_active_output;  	// rozdzielczosc - tylko aktywyny obszar - wyjscie

	int active_input;
	int active_output;


	int vdma_write_SR;



	int step = 0;


	while(1) {
		sleep(5);   // delay

		hsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0030);
		vsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0034);
		hsize_output = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0070);
		hsize_output = hsize_output & 0x00000FFF;
		vsize_output = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0074);
		vsize_output = vsize_output & 0x00000FFF;


		active_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0020);
		active_output = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0020);
		vsize_active_input = (active_input & 0xFFFF0000) >> 16;
		hsize_active_input = active_input & 0x0000FFFF;

		vsize_active_output = (active_output & 0xFFFF0000) >> 16;
		hsize_active_output = active_output & 0x0000FFFF;

		// VDMA Control register
		vdma_write_SR = Xil_In32(XPAR_AXI_VDMA_0_BASEADDR+S2MM_VDMASR);

		// Display
    	xil_printf("-------------------------------------------\n\r");
    	xil_printf("%d\n\r",step);
    	xil_printf("Image IN ACTIVE  %d x %d \n\r",hsize_active_input,vsize_active_input);
  	    xil_printf("Image IN  %d x %d \n\r",hsize_input,vsize_input);
  	    xil_printf("Image OUT ACTIVE %d x %d \n\r",hsize_active_output,vsize_active_output);
   	    xil_printf("Image OUT %d x %d \n\r",hsize_output,vsize_output);
   	    xil_printf("WRITE CR %X \n\r",vdma_write_SR);


   	    // Test transfer image
   	    for (int j=500; j < 510; j++) {
   	    	for (int i=500; i < 510; i++) {
   	    		xil_printf("%X ",hdmi_image2[HSIZE_ACTVIE*j+i]);
   	    	}
   	    	xil_printf("\n\r");
   	    }

   	    step++;

	}



	cleanup_platform();
	return 0;
}
