/*
 * Empty C++ Application
 */

#include "xparameters.h"
#include "platform.h"
#include "xil_printf.h"
#include "xil_io.h"
#include "sleep.h"
#include "xaxivdma.h"


// VDMA (write) registers
#define S2MM_VDMACR 0x30
#define S2MM_VDMASR 0x34
#define S2MM_VSIZE 0xA0
#define S2MM_HSIZE 0xA4
#define S2MM_FRMDLY_STRIDE 0xA8
#define S2MM_START_ADDRESS 0xAC

#define MM2S_VDMACR 0x00
#define MM2S_VDMASR 0x04
#define MM2S_VSIZE 0x50
#define MM2S_HSIZE 0x54
#define MM2S_FRMDLY_STRIDE 0x58
#define MM2S_START_ADDRESS 0x5C

// Full (with blanking) input image sizes
#define HSIZE_FULL 1980
#define VSIZE_FULL 750

// Active (only video) image sizes
#define HSIZE_ACTIVE 1280
#define VSIZE_ACTIVE 720


// Buffer for input image
u8 hdmi_image_in[VSIZE_ACTIVE*HSIZE_ACTIVE*3] ={0};
//u32 hdmi_image_out[VSIZE_ACTIVE*HSIZE_ACTVIE];


XAxiVdma AxiVdma;

int AxiVDMASelfTestExample(u16 DeviceId)
{
	XAxiVdma_Config *Config;
	int Status = XST_SUCCESS;

	Config = XAxiVdma_LookupConfig(DeviceId);
	if (!Config) {
			return XST_FAILURE;
	}

	/* Initialize DMA engine */
	Status = XAxiVdma_CfgInitialize(&AxiVdma, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	Status = XAxiVdma_Selftest(&AxiVdma);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	return Status;
}


int main()
{
	init_platform();


	xil_printf("VDMA image transfer \n\r");

	// Initialize VTC
	Xil_Out32(XPAR_V_TC_0_BASEADDR,0xC);

	// Czekanie na video
	int hsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0030);
	int vsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0034);

	xil_printf("Waiting for image stream to synchornize \n\r");
	while ( hsize_input <=1 && vsize_input <=1) {
		hsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0030);
		vsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0034);
	}
	xil_printf("Stream synchornized \n\r");


	int *a = new int;
	(*a)=1;

	//u8 *hdmi_image_in = new u8[HSIZE_ACTIVE*VSIZE_ACTIVE*4];


	// VDMA Self test
	int  Status = AxiVDMASelfTestExample(XPAR_AXI_VDMA_0_DEVICE_ID);
    if (Status != XST_SUCCESS)
    	xil_printf("AxiVDMASelfTestExample: Failed\r\n");
	else
		xil_printf("AxiVDMASelfTestExample: Passed\r\n");


	//u32* mem_address = &hdmi_image;
	xil_printf("Image address %X \r\n",(u32)(hdmi_image_in));
	xil_printf("Image address %X \r\n",(&hdmi_image_in));


	// Initialize VDMA Write
	Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_VDMACR,0x8B); // run  8B
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_START_ADDRESS, (u32)(&hdmi_image_in));
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_FRMDLY_STRIDE,HSIZE_ACTIVE*3);   // 0
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_HSIZE,HSIZE_ACTIVE*3);          // 4
    Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + S2MM_VSIZE,VSIZE_ACTIVE);            //

    //Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + MM2S_VDMACR,0x8B); // run  8B
    //Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + MM2S_START_ADDRESS, (u32)(&hdmi_image_in));
    //Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + MM2S_FRMDLY_STRIDE,HSIZE_ACTIVE*3);   // 0
    //Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + MM2S_HSIZE,HSIZE_ACTIVE*3);          // 4
    //Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + MM2S_VSIZE,VSIZE_ACTIVE);            //



    // Clear memory
    for (int j=0; j < VSIZE_ACTIVE*HSIZE_ACTIVE*3; j++) {  //
    	hdmi_image_in[j] = 0;
    	//xil_printf("%d ",hdmi_image[j]);
    }



	//int hsize_input, vsize_input;  					// rozdzielczosc - cala ramka - wejscie
	int hsize_active_input, vsize_active_input;  	// rozdzielczosc - tylko aktywyny obszar - wejscie

	int hsize_output, vsize_output;  				// rozdzielczosc - cala ramka - wyjscie
	int hsize_active_output, vsize_active_output;  	// rozdzielczosc - tylko aktywyny obszar - wyjscie

	int active_input;
	int active_output;


	u32 vdma_write_SR,vdma_read_SR;



	int step = 0;


	while(1) {
		sleep(5);   // delay

		hsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0030);
		vsize_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0034);
		hsize_output = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0070);
		hsize_output = hsize_output & 0x00000FFF;
		vsize_output = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0074);
		vsize_output = vsize_output & 0x00000FFF;


		active_input = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0020);
		active_output = Xil_In32(XPAR_V_TC_0_BASEADDR+0x0020);
		vsize_active_input = (active_input & 0xFFFF0000) >> 16;
		hsize_active_input = active_input & 0x0000FFFF;

		vsize_active_output = (active_output & 0xFFFF0000) >> 16;
		hsize_active_output = active_output & 0x0000FFFF;

		// VDMA Control register
		vdma_write_SR = Xil_In32(XPAR_AXI_VDMA_0_BASEADDR+S2MM_VDMASR);
		vdma_read_SR  = Xil_In32(XPAR_AXI_VDMA_0_BASEADDR+MM2S_VDMASR);


		// Display
    	xil_printf("-------------------------------------------\n\r");
    	xil_printf("%d\n\r",step);
    	xil_printf("Image IN ACTIVE  %d x %d \n\r",hsize_active_input,vsize_active_input);
  	    xil_printf("Image IN  %d x %d \n\r",hsize_input,vsize_input);
  	    xil_printf("Image OUT ACTIVE %d x %d \n\r",hsize_active_output,vsize_active_output);
   	    xil_printf("Image OUT %d x %d \n\r",hsize_output,vsize_output);
   	    xil_printf("WRITE CR %X \n\r",vdma_write_SR);
   	    xil_printf("READ CR %X \n\r",vdma_read_SR);



   	    // Test transfer image

   	    for (int j=0; j < 60; j++) {
   	    	for (int i=0; i < 3*60; i+=3) {
   	    		xil_printf("%d %d %d \n",hdmi_image_in[j*HSIZE_ACTIVE*3+i],hdmi_image_in[j*HSIZE_ACTIVE*3+i+1],hdmi_image_in[j*HSIZE_ACTIVE*3+i+2]);
   	    	}
   	    }


   	   // Clear memory
   	    for (int j=0; j < VSIZE_ACTIVE*HSIZE_ACTIVE*3; j++) {  //
   	    	hdmi_image_in[j] = 0;
   	    //	//xil_printf("%d ",hdmi_image[j]);
   	    }


   	    step++;

	}



	cleanup_platform();
	//delete [] hdmi_image_in;
	return 0;
}
